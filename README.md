# Computer_Science_Interview
각 폴더에 해당하는 과목의 이론을 정리했습니다.   
어느정도 내용 입력 후 총괄적으로 이 페이지에 정리할 예정입니다.

---
# 알고리즘
코딩 테스트에서는 잘 사용해도 정의에 대해 설명을 professional하게 하지 못하는 경우를 방지하기 위해 각 알고리즘의 정의를 기록
동빈나님의 알고리즘 강의 및 구글링 참조

---
## 깊이 우선 탐색(DFS, Depth-First Search)

- 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘

- 탐색 시작 노드에서 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방식

- 스택 자료구조 or 재귀 함수를 사용하며 구체적인 동작은 아래와 같음
  
  1. 탐색 시작 노드를 스택에 삽입하고 방문 처리
  
  2. 스택의 최상단 노드에 방문하지 않은 인접한 노드가 하나라도 있으면 그 노드를 스택에 넣고 방문 처리   
     방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼냄
  
  3. 더 이상 2번 과정을 수행할 수 없을 때까지 반복

<img src="https://user-images.githubusercontent.com/101415950/194974462-2c650675-1607-4f56-bdb4-9bc5c61b5d45.gif" width="40%" height="40%">
(출처 https://developer-mac.tistory.com/64)

---
## 너비 우선 탐색(BFS, Breadth-First Search)

- 그래프에서 가까운 노드부터 우선적으로 탐색하는 알고리즘

- 탐색 시작 노드에서 시작해서 인접한 노드를 먼저 탐색하는 방식

- Queue 자료구조를 사용하며 구체적인 동작은 아래와 같음
  
  1. 탐색 시작 노드를 큐에 삽입하고 방문 처리
  
  2. 큐에서 노드를 꺼낸 후 해당 노드의 인접 노드 중 방문하지 않은 노드를 모두 큐에 삽입 및 방문처리
  
  3. 더 이상 2번 과정을 수행할 수 없을 때까지 반복

<img src="https://user-images.githubusercontent.com/101415950/194974879-88205f00-14a0-41f0-9219-3f7fad0a6358.gif" width="40%" height="40%">
(출처 https://developer-mac.tistory.com/64)

---
## 다익스트라 알고리즘(Dijkstra)

- 특정한 노드에서 출발하여 모든 노드로 가는 최단 경로를 계산하는 알고리즘

- 음의 간선이 없을 때 동작

- 그리디 알고리즘에 속함

- 최단경로 계산 시 현재 노드에서부터 다른 노드 각각에 대한 최단 거리를 1차원 리스트에 저장하여 갱신

- 노드와 간선 수가 많을 때 다익스트라, 노드의 개수가 적을 때는 플로이드 워셜 알고리즘이 효과적

- 힙 자료구조 사용 시 시간복잡도 O(ElogV) (E : 최대 간선의 갯수, V : 노드의 갯수)
  
  1. 출발 노드 선택 후 최단 거리 테이블 출발 노드를 제외한 모든 값을 무한으로 초기화
  
  2. 방문하지 않은 노드 중 최단 거리 테이블 내 최단 거리에 있는 노드 선택
 
  3. 선택한 노드를 거쳐 다른 노드로 가는 거리 각각 계산
  
  4. 최단 거리 테이블 내 노드별 거리가 계산한 값보다 클 경우 계산한 값으로 갱신

  5. 2번~4번 과정 불가능할 때까지 반복

<img src="https://user-images.githubusercontent.com/101415950/196177010-28225a74-b08d-42e3-8d05-9e8581d9163e.png" width="80%" height="80%">

(출처 https://www.youtube.com/watch?v=F-tkqjUiik0&list=PLVsNizTWUw7H9_of5YCB0FmsSc-K44y81&index=30)

---
## 플로이드 워셜 알고리즘(Floyd-Warshall)

- 모든 노드에서 다른 모든 노드로 가는 최단 경로를 계산하는 알고리즘

- 다이나믹 프로그래밍 유형에 속함

- 최단경로 계산 시 최단 거리를 2차원 리스트에 저장하여 갱신

- 노드와 간선 수가 많을 때 다익스트라, 노드의 개수가 적을 때는 플로이드 워셜 알고리즘이 효과적

- 각 단계마다 특정한 노드 k를 거쳐 가는 경우 확인
  
  1. 최단 거리 2차원 테이블 초기화
  
  2. 1번 노드를 거쳐가는 경우를 고려하여 테이블 갱신 ~ n번 노드를 거쳐가는 경우를 고려한 테이블 갱신

<img src="https://user-images.githubusercontent.com/101415950/196182624-c03cc0c8-cb02-45ca-8bd3-56bfad61abaf.png" width="80%" height="80%">

(출처 https://www.youtube.com/watch?v=hw-SvAR3Zqg&list=PLVsNizTWUw7H9_of5YCB0FmsSc-K44y81&index=31)

---
## 유니온 파인드(Union-Find)


- 두 노드가 같은 그래프에 속하는지 판별하는 알고리즘

- 서로소 집합, 상호 베타적 집합(Disjoint_Set)으로도 불림

- 루트 노드를 찾는 Find 연산과 노드를 합치는 Union 연산(두 노드의 루트 노드를 비교하여 한쪽으로 합침)으로 구성

[Example]   
<img src="https://user-images.githubusercontent.com/101415950/196175786-def50ef9-1305-4077-b8ec-773fffefb99e.png" width="80%" height="80%">
<img src="https://user-images.githubusercontent.com/101415950/196175860-e682fef2-915e-4aea-b307-c1d56de620ed.png" width="80%" height="80%">
(출처 https://ip99202.github.io/posts/%EC%9C%A0%EB%8B%88%EC%98%A8-%ED%8C%8C%EC%9D%B8%EB%93%9C(Union-Find)/)

---
# 자료구조

---
## 힙

- 최대값 혹은 최소값을 빠르게 찾기 위한 이진 트리

- 최소 힙은 부모가 자식보다 작음

- 최대 힙은 부모가 자식보다 큼

- 힙의 삽입과 삭제는 LogN만큼의 시간복잡도를 가짐

---
## 이진 탐색 트리

- 왼쪽 자식은 부모보다 작고 오른쪽 자식은 부모보다 큰 이진 트리

- 삽입, 검색, 삭제가 모두 트리의 높이인 logN~N만큼의 시간복잡도 가짐

- 그래서 트리가 편향되지 않기 위해 자가 균형 트리 사용

---
## 자가 균형 트리

- 이진 탐색 트리는 시간복잡도가 트리의 높이에 따라 결정되므로 편향될 경우 효율이 떨어짐 

- 편향되지 않게 삽입과 삭제를 개선한 이진 탐색 트리가 자가 균형 트리

- AVL 트리와 Red Black 트리가 있음

---
## 해시

- 해시에 매핑하여 데이터를 저장하는 자료구조

- 키는 해시 함수를 통해 해시로 변경된 다음 value와 매핑이 되어 bucket에 저장

- 시간복잡도는 삽입, 삭제, 조회 모두 1

---
## 해시 충돌 회피 방법

- 해시에서 하나의 버킷에 여러개의 데이터가 들어갈때 개방주소법과 체이닝을 통해 충돌 회피
  
  - 개방주소법 : 다른 해시값에 저장하는 방법
  
  - 체이닝 : 해쉬테이블이 원소 하나를 담는게 아니라 링크드 리스트를 담는 방법
