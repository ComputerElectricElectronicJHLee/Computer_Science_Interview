# Computer_Science_Interview
각 폴더에 해당하는 과목의 이론을 정리했습니다.   
어느정도 내용 입력 후 총괄적으로 이 페이지에 정리할 예정입니다.

---
# 알고리즘
코딩 테스트에서는 잘 사용해도 정의에 대해 설명을 professional하게 하지 못하는 경우를 방지하기 위해 각 알고리즘의 정의를 기록
동빈나님의 알고리즘 강의 및 구글링 참조

---
## 깊이 우선 탐색(DFS, Depth-First Search)

- 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘

- 탐색 시작 노드에서 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방식

- 스택 자료구조 or 재귀 함수를 사용하며 구체적인 동작은 아래와 같음
  
  1. 탐색 시작 노드를 스택에 삽입하고 방문 처리
  
  2. 스택의 최상단 노드에 방문하지 않은 인접한 노드가 하나라도 있으면 그 노드를 스택에 넣고 방문 처리   
     방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼냄
  
  3. 더 이상 2번 과정을 수행할 수 없을 때까지 반복

<img src="https://user-images.githubusercontent.com/101415950/194974462-2c650675-1607-4f56-bdb4-9bc5c61b5d45.gif" width="40%" height="40%">
(출처 https://developer-mac.tistory.com/64)

---
## 너비 우선 탐색(BFS, Breadth-First Search)

- 그래프에서 가까운 노드부터 우선적으로 탐색하는 알고리즘

- 탐색 시작 노드에서 시작해서 인접한 노드를 먼저 탐색하는 방식

- Queue 자료구조를 사용하며 구체적인 동작은 아래와 같음
  
  1. 탐색 시작 노드를 큐에 삽입하고 방문 처리
  
  2. 큐에서 노드를 꺼낸 후 해당 노드의 인접 노드 중 방문하지 않은 노드를 모두 큐에 삽입 및 방문처리
  
  3. 더 이상 2번 과정을 수행할 수 없을 때까지 반복

<img src="https://user-images.githubusercontent.com/101415950/194974879-88205f00-14a0-41f0-9219-3f7fad0a6358.gif" width="40%" height="40%">
(출처 https://developer-mac.tistory.com/64)

---
## 다익스트라 알고리즘(Dijkstra)

- 특정한 노드에서 출발하여 모든 노드로 가는 최단 경로를 계산하는 알고리즘

- 음의 간선이 없을 때 동작

- 그리디 알고리즘에 속함

- 최단경로 계산 시 현재 노드에서부터 다른 노드 각각에 대한 최단 거리를 1차원 리스트에 저장하여 갱신

- 노드와 간선 수가 많을 때 다익스트라, 노드의 개수가 적을 때는 플로이드 워셜 알고리즘이 효과적

- 힙 자료구조 사용 시 시간복잡도 O(ElogV) (E : 최대 간선의 갯수, V : 노드의 갯수)
  
  1. 출발 노드 선택 후 최단 거리 테이블 출발 노드를 제외한 모든 값을 무한으로 초기화
  
  2. 방문하지 않은 노드 중 최단 거리 테이블 내 최단 거리에 있는 노드 선택
 
  3. 선택한 노드를 거쳐 다른 노드로 가는 거리 각각 계산
  
  4. 최단 거리 테이블 내 노드별 거리가 계산한 값보다 클 경우 계산한 값으로 갱신

  5. 2번~4번 과정 불가능할 때까지 반복

<img src="https://user-images.githubusercontent.com/101415950/196177010-28225a74-b08d-42e3-8d05-9e8581d9163e.png" width="80%" height="80%">

(출처 https://www.youtube.com/watch?v=F-tkqjUiik0&list=PLVsNizTWUw7H9_of5YCB0FmsSc-K44y81&index=30)

---
## 플로이드 워셜 알고리즘(Floyd-Warshall)

- 모든 노드에서 다른 모든 노드로 가는 최단 경로를 계산하는 알고리즘

- 다이나믹 프로그래밍 유형에 속함

- 최단경로 계산 시 최단 거리를 2차원 리스트에 저장하여 갱신

- 노드와 간선 수가 많을 때 다익스트라, 노드의 개수가 적을 때는 플로이드 워셜 알고리즘이 효과적

- 각 단계마다 특정한 노드 k를 거쳐 가는 경우 확인
  
  1. 최단 거리 2차원 테이블 초기화
  
  2. 1번 노드를 거쳐가는 경우를 고려하여 테이블 갱신 ~ n번 노드를 거쳐가는 경우를 고려한 테이블 갱신

<img src="https://user-images.githubusercontent.com/101415950/196182624-c03cc0c8-cb02-45ca-8bd3-56bfad61abaf.png" width="80%" height="80%">

(출처 https://www.youtube.com/watch?v=hw-SvAR3Zqg&list=PLVsNizTWUw7H9_of5YCB0FmsSc-K44y81&index=31)

---
## 유니온 파인드(Union-Find)


- 두 노드가 같은 그래프에 속하는지 판별하는 알고리즘

- 서로소 집합, 상호 베타적 집합(Disjoint_Set)으로도 불림

- 루트 노드를 찾는 Find 연산과 노드를 합치는 Union 연산(두 노드의 루트 노드를 비교하여 한쪽으로 합침)으로 구성

[Example]   
<img src="https://user-images.githubusercontent.com/101415950/196175786-def50ef9-1305-4077-b8ec-773fffefb99e.png" width="80%" height="80%">
<img src="https://user-images.githubusercontent.com/101415950/196175860-e682fef2-915e-4aea-b307-c1d56de620ed.png" width="80%" height="80%">
(출처 https://ip99202.github.io/posts/%EC%9C%A0%EB%8B%88%EC%98%A8-%ED%8C%8C%EC%9D%B8%EB%93%9C(Union-Find)/)

---
# 자료구조

---
## 힙

- 최대값 혹은 최소값을 빠르게 찾기 위한 이진 트리

- 최소 힙은 부모가 자식보다 작음

- 최대 힙은 부모가 자식보다 큼

- 힙의 삽입과 삭제는 LogN만큼의 시간복잡도를 가짐

---
## 이진 탐색 트리

- 왼쪽 자식은 부모보다 작고 오른쪽 자식은 부모보다 큰 이진 트리

- 삽입, 검색, 삭제가 모두 트리의 높이인 logN~N만큼의 시간복잡도 가짐

- 그래서 트리가 편향되지 않기 위해 자가 균형 트리 사용

---
## 자가 균형 트리

- 이진 탐색 트리는 시간복잡도가 트리의 높이에 따라 결정되므로 편향될 경우 효율이 떨어짐 

- 편향되지 않게 삽입과 삭제를 개선한 이진 탐색 트리가 자가 균형 트리

- AVL 트리와 Red Black 트리가 있음

---
## 해시

- 해시에 매핑하여 데이터를 저장하는 자료구조

- 키는 해시 함수를 통해 해시로 변경된 다음 value와 매핑이 되어 bucket에 저장

- 시간복잡도는 삽입, 삭제, 조회 모두 1

---
## 해시 충돌 회피 방법

- 해시에서 하나의 버킷에 여러개의 데이터가 들어갈때 개방주소법과 체이닝을 통해 충돌 회피
  
  - 개방주소법 : 다른 해시값에 저장하는 방법
  
  - 체이닝 : 해쉬테이블이 원소 하나를 담는게 아니라 링크드 리스트를 담는 방법

---
# 데이터베이스

---
## DBMS

- 데이터베이스 내 데이터에 접근하도록 도와주는 시스템

- 크게 질의처리기와 저장시스템으로 이루어짐

---
## 트랜잭션 특징 ACID

- 데이터베이스의 무결성과 일관성을 위해 ACID를 만족해야함

  - 원자성 : 한 트랜잭션 내 실행 작업은 모두 반영하거나 모두 반영하지 않아야 한다.

  - 일관성 : 작업 처리 결과는 항상 일관적이어야 한다.

  - 독립성 : 동시에 실행되는 트랜잭션은 서로에게 영향을 끼치지 않아야 한다.

  - 지속성 : 트랜잭션 완료시 결과가 영구적으로 반영

---
## NOSQL(Not Only SQL)

- SQL을 보완한다는 의미를 가짐

- 스키마가 없어서 데이터를 조회하고 삽입하는 속도가 빠름

- 대량의 분산 데이터를 저장하는데 특화됨

---
## 파티셔닝

- 테이블을 컬럼 단위로 나누는 기법

- update나 insert 같은 작업이 분산되어서 성능이 향상

- 테이블간 join 비용 증가

- index를 별도로 파티셔닝할 수 없음

---
## 샤딩(Horizontal 파티셔닝)

- 테이블을 row 단위로 분산해서 저장하는 방법

- 샤드 키를 정하는 방법에 따라서 샤드 종류가 결정

- 크게 해시 샤딩(해시키 이용)과 동적 샤딩(로케이터 서비스 이용)이 있음

---
## 데이터 베이스 정규화, 비정규화

- 정규화

  - 테이블을 분할하여 중복 데이터를 제거함으로써 데이터 무결성을 유지하는 행위
  
  - 1정규화(1NF) : 도메인이 원자값   
      
    <img src="https://user-images.githubusercontent.com/101415950/195033077-8eaaa90a-ceaa-4f0f-a1ee-f1fa0fa1d39b.png" width="60%" height="60%">

  - 2정규화(2NF) : 부분적 함수 종속 제거   
      
    <img src="https://user-images.githubusercontent.com/101415950/195034681-dda3722c-2923-47e0-8d04-7abdd2ce7c99.png" width="80%" height="80%">

  - 3정규화(3NF) : 이행적 함수 종속 제거   
      
    <img src="https://user-images.githubusercontent.com/101415950/195034701-18d90abe-850f-46d4-b371-403ccf8dd04b.png" width="80%" height="80%">

  - BCNF(보이스코드 정규화) : 결정자이면서 후보키가 아닌 것을 제거   
  
    - 교수는 과목을 결정 짓는 결정자

    - 교수는 학번을 결정 지을 수 없으므로 후보키가 아님, 제거 대상
  
    <img src="https://user-images.githubusercontent.com/101415950/195036347-bf205642-ec79-4cd4-af2c-8971f863b81d.png" width="80%" height="80%">

  - 4정규화(4NF) : 다치(다중) 종속 제거
    
    - 다치종속 : 두개의 독립된 애트리뷰트가 1:N 관계로 대응하는 관계
  
    ![image](https://user-images.githubusercontent.com/101415950/195234161-eab7d116-a95f-4bce-9e65-a921affdb232.png)
  
  - 5정규화(5NF) : 조인 종속 제거
    
    - Join 종속 : 하나의 릴레이션을 무손실, 비부가적 분해하고 나서 다시 합쳤을 때 원래의 릴레이션으로 복원 가능한 관계

    ![image](https://user-images.githubusercontent.com/101415950/195247702-96354a74-6d70-4ec9-87c9-6f61759f6780.png)

- 비정규화

  - 데이터베이스 성능 향상 등을 위해 중복, 통합, 분리 등을 수행하여
    의도적으로 정규형을 위배한 데이터 구조로 만드는 행위
    

---
## DBMS 기능

- 데이터 정의어(DDL, Data Definition Language)

  - 테이블과 컬럼을 정의하는 명령어로 생성, 수정, 삭제 등의 데이터 전체 골격을 결정하는 언어

  - ex. CREATE, ALTER, DROP, RENAME, TRUNCATE

- 데이터 조작어(DML, Data Manipulation Language)

  - 데이터베이스의 내부 데이터를 관리하기 위한 언어로 데이터를 조회, 추가, 변경, 삭제 등의 작업을 수행

  - SELECT, INSERT, UPDATE, DELETE

- 데이터 제어어(DCL, Data Control Language)

  - 데이터베이스에 접근하고 객체들을 사용하도록 권한을 주고 회수하는 명령

  - GRANT, REVOKE

- 트랜잭션 제어어(DDL, Transaction Control Language)

  - 데이터를 제어하는 언어가 아닌 DML에 의해 조작된 결과를 논리적인 작업 단위로 묶어 트랜잭션 별로 제어
  
  - COMMIT, ROLLBACK, SAVEPOINT

---
# 디자인 패턴

---
## 디자인 패턴

- 과거 소프트웨어 개발 과정에서 발견한 설계 노하우를 패턴으로 정리한 것

- 범용적인 코드스타일로 의사소통을 효율적으로 할 수 있음

- 이미 검증된 구조이므로 설계를 빠르게 할 수 있음

- 목적에 따라서 생성패턴, 구조패턴, 행위패턴으로 나뉘게 됨
---
## 싱글톤 패턴

- 인스턴스를 오직 1개만 생성하는 패턴

- 예를 들면 DB 커넥션이나 스레드 풀 객체를 생성할 때 사용

- 만드는 방법으로 이른 초기화 방식, 게으른 초기화 방식, Holder에 의한 초기화 방식이 있음

---
## 팩토리 메소드 패턴

- 객체를 직접 생성하지 않고 객체를 생성하는 팩토리 객체를 사용하는 패턴

- 직접 객체를 생성하는 것을 막아줘서 결합도를 낮춰주는 효과

---
## 어댑터 패턴

- 어댑터를 사용해서 호환되지 않는 인터페이스를 호환하도록 하는 패턴

- 향후 인터페이스가 바뀌더라도 변경된 내용이 어댑터 안에 캡슐화되므로 수정할 필요가 없음

---
## 템플릿 메소드 패턴

- 상속을 통해서 부모 클래스의 기능을 확장할 때 사용

- 부모 클래스에서 변하지 않는 기능을 구현

- 자식 클래스에서 확장할 기능을 구현

- 자바에서는 추상 클래스를 사용해서 구현

- 대표적으로 AbstractMap이 있음
  
  - AbstractMap에서 공통된 기능을 정의
  
  - 상속받은 HashMap이나 TreeMap에서 각각의 자료구조에 맞게 get() 메소드를 다르게 구현


