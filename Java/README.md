
# 자바

---
## 자바 실행과정

- 컴파일러가 자바 소스를 바이트 코드로 변환

- 클래스 로더가 바이트 코드를 런타임 데이터 영역에 로드

- 로딩된 바이트 코드가 실행엔진에 의해서 실행

---
## 자바 메모리 구조

- 스레드마다 pc 레지스터, jvm stack, native method stack으로 구성
  
  - pc 레지스터 : 현재 수행중인 jvm 명령어가 들어있음
  
  - jvm stack : 호출된 메소드의 매개변수, 지역변수, 리턴정보들이 저장
  
  - native method stack : 자바 외의 언어인 C나 C++ 같은 것들을 수행하기 위한 영역

- 스레드 공통으로 heap과 메소드 영역으로 구성

  
  - 메소드 영역 : 클래스 별로 전역변수, 정적 변수, 메소드 정보들이 저장
  
  - heap 영역 : 런타임 중 생성되는 객체들(new로 생성된 인스턴스 등)이 동적으로 할당되는 곳

---
## 가비지 컬렉션(GC)

- GC는 JVM에서 메모리를 관리해주는 모듈

- heap 메모리를 재사용하기 위해서 더 이상 참조되지 않는 객체들을 메모리에서 제거하는 모듈

- 개발자가 직접 메모리를 정리하지 않아도 되서 개발속도가 향상되는 장점

- Mark and Sweep이라는 과정에서 참조되지 않는 객체를 찾는 과정에서 스레드가 잠깐 중단되므로 성능이 떨어짐

---
## 객체 지향 프로그래밍

- 현실 세계의 사물과 같은 객체를 만들고 그 객체에서 필요한 특징을 뽑아서 프로그래밍을 수행

- 추상화 캡슐화 다형성 상속 특징이 있음

---
## 추상클래스 인터페이스

- 추상클래스
  
  - abstract 지시자로 정의되어서 추상메소드가 하나 이상 포함되는 클래스

  - 상속받아서 기능을 재활용하고 확장시키는 목적

- 인터페이스

  - interface 지시자로 정의되어서 모든 메소드가 추상메소드로 정의

  - 함수의 구현을 강제해서 구현한 객체들이 같은 동작을 하는 것을 보장하는 것에 목적
  
  ---
## 깊은 복사(Deep Copy, Call by value), 얉은 복사(Shallow Copy, Call by reference)

- 깊은 복사(Deep Copy, Call by value)
  
  - 새로운 메모리 공간을 만들어서 실제 값을 복사

  - 실제 값과 복사 값이 서로 다른 메모리에 저장

- 얉은 복사(Shallow Copy, Call by reference)

  - 객체의 주소값을 복사하는 방식으로 원본에 영향을 줄 수 있음

  - 실제값과 복사 값이 동일한 메모리 참조
